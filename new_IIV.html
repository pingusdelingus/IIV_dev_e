<html>
  <body>
    <script
      src="https://unpkg.com/@hpcc-js/wasm@1.20.1/dist/index.js"
      type="text/javascript"
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-graphviz@4.4.0/build/d3-graphviz.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script>
      document.body.onload = function() {
        window.stuff = document.querySelectorAll("body > pre");
        window.stuff[0].innerText = "";
        window.stuff[1].innerText = "";
      };
    </script>
    <script>
      window.interpretation = true;
    </script>

    <style>
      html,
      body {
        font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
        padding: 0px;
        width: 100%;
        height: 100%;
      }

      * {
        /* word-break: break-all; */
      }

      body {
        justify-content: space-around;
        align-items: flex-start;
      }

      /* loading symbol stuff */

      #loadingSymbol,
      g.node,
      g.node > polygon,
      g.node > ellipse {
        transition: opacity 0.3s, fill 0.3s;
      }

      #loadingSymbol {
        position: fixed;
        padding: 45px;
        right: 20px;
        top: 20px;
        background-color: rgba(150, 150, 150, 0.2);
        border-radius: 100px;
        box-shadow: 2px 2px 5px 0px rgb(177, 177, 177);
        opacity: 1;
      }

      #loadingSymbol.hidden {
        opacity: 0;
        height: 0px;
        width: 0px;
        padding: 0px;
        margin: 0px;
      }

      /* settings stuff */

      .interestHidden {
        display: none;
      }

      .settingsHeader {
        cursor: pointer;
      }

      .triangle {
        border: solid black;
        border-width: 0 3px 3px 0;
        display: inline-block;
        padding: 3px;

        transform: rotate(45deg) translateY(-4px);
      }

      .open > .triangle {
        transform: rotate(-135deg) translate(-3px, 3px);
      }

      .collapsable {
        overflow: auto;
        padding: 0px;
      }

      .box {
        border: 1px solid black;
        background: rgba(100, 100, 100, 0.4);
        padding: 10px;
        margin: 5px;
      }

      #nodeInfo {
        overflow: auto;
        font-family: monospace;
      }

      #settings {
        /* position: fixed; */
        left: 5px;
        max-height: 96%;
        width: 550px;
        top: 2%;
        user-select: none;
        overflow: auto;
        border-right: 1px solid black;

        font-size: 0.87em;
      }

      #tptpTextarea {
        display: none;
        width: 90%;
        margin: auto;
        border: 0px;
        min-height: 100px;
        height: 0px;
      }

      #tptpTextarea.open {
        height: auto;
        display: block;
      }

      button,
      input[type="button"] {
        position: relative;
        display: block;
        margin-top: 10px;

        padding: 10px;
        border-radius: 5px;
        border: 1px solid black;
        background-color: rgb(201, 201, 201);
        cursor: pointer;

        font-size: 0.9em;
      }

      button:hover,
      input[type="button"]:hover {
        top: -1px;
        left: -1px;
        box-shadow: 1px 1px 7px -3px black;
      }

      .settingsHeader {
        line-height: 2.5;
        margin: 0px;
        padding: 0px;
      }

      /* graphviz */

      #graph svg {
        width: 100%;
        height: 100%;
      }

      /* generated slider css */

      input[type="range"].mySlider {
        -webkit-appearance: none;
        width: 90%;
        margin: auto;
      }
      input[type="range"].mySlider:focus {
        outline: none;
      }
      input[type="range"].mySlider::-webkit-slider-runnable-track {
        width: 100%;
        height: 17.8px;
        cursor: pointer;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
        background: rgba(192, 192, 190, 0.76);
        border-radius: 0px;
        border: 1.2px solid rgba(0, 0, 0, 0);
      }
      input[type="range"].mySlider::-webkit-slider-thumb {
        box-shadow: 1.7px 1.7px 9.5px rgba(0, 0, 0, 0.51),
          0px 0px 1.7px rgba(13, 13, 13, 0.51);
        border: 2.4px solid rgba(44, 30, 0, 0.56);
        height: 29px;
        width: 26px;
        border-radius: 9px;
        background: rgba(148, 136, 126, 0.98);
        cursor: pointer;
        -webkit-appearance: none;
        margin-top: -6.8px;
      }
      input[type="range"].mySlider:focus::-webkit-slider-runnable-track {
        background: rgba(192, 192, 190, 0.76);
      }
      input[type="range"].mySlider::-moz-range-track {
        width: 100%;
        height: 17.8px;
        cursor: pointer;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
        background: rgba(192, 192, 190, 0.76);
        border-radius: 0px;
        border: 1.2px solid rgba(0, 0, 0, 0);
      }
      input[type="range"].mySlider::-moz-range-thumb {
        box-shadow: 1.7px 1.7px 9.5px rgba(0, 0, 0, 0.51),
          0px 0px 1.7px rgba(13, 13, 13, 0.51);
        border: 2.4px solid rgba(44, 30, 0, 0.56);
        height: 29px;
        width: 26px;
        border-radius: 9px;
        background: rgba(148, 136, 126, 0.98);
        cursor: pointer;
      }
      input[type="range"].mySlider::-ms-track {
        width: 100%;
        height: 17.8px; 
        cursor: pointer;
        background: transparent;
        border-color: transparent;
        color: transparent;
      }
      input[type="range"].mySlider::-ms-fill-lower {
        background: rgba(192, 192, 190, 0.76);
        border: 1.2px solid rgba(0, 0, 0, 0);
        border-radius: 0px;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
      }
      input[type="range"].mySlider::-ms-fill-upper {
        background: rgba(192, 192, 190, 0.76);
        border: 1.2px solid rgba(0, 0, 0, 0);
        border-radius: 0px;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
      }
      input[type="range"].mySlider::-ms-thumb {
        box-shadow: 1.7px 1.7px 9.5px rgba(0, 0, 0, 0.51),
          0px 0px 1.7px rgba(13, 13, 13, 0.51);
        border: 2.4px solid rgba(44, 30, 0, 0.56);
        height: 29px;
        width: 26px;
        border-radius: 9px;
        background: rgba(148, 136, 126, 0.98);
        cursor: pointer;
        height: 17.8px;
      }
      input[type="range"].mySlider:focus::-ms-fill-lower {
        background: rgba(192, 192, 190, 0.76);
      }
      input[type="range"].mySlider:focus::-ms-fill-upper {
        background: rgba(192, 192, 190, 0.76);
      }

      /**
 * ==============================================
 * Dot Revolution
 * ==============================================
 */
      .dot-revolution {
        position: relative;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
      }

      .dot-revolution::before,
      .dot-revolution::after {
        content: "";
        display: inline-block;
        position: absolute;
      }

      .dot-revolution::before {
        left: 0;
        top: -15px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        transform-origin: 5px 20px;
        animation: dotRevolution 1.4s linear infinite;
      }

      .dot-revolution::after {
        left: 0;
        top: -30px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        transform-origin: 5px 35px;
        animation: dotRevolution 1s linear infinite;
      }

      @keyframes dotRevolution {
        0% {
          transform: rotateZ(0deg) translate3d(0, 0, 0);
        }
        100% {
          transform: rotateZ(360deg) translate3d(0, 0, 0);
        }
      }

      /*# sourceMappingURL=three-dots.css.map */
    </style>
    <div id="index">
      <pre id="output" style="display: none">
PROOF_GOES_HERE
      </pre>

      <input type="file" name="fileUploadBtn" id="fileUploadBtn" style="display:none"/>
      <button id="visualizeBtn" onclick="visualize()" style="display:none">Visualize</button>
    </div>

    <div id="idv" style="display: none; align-items: flex-start; height: 100%">
      <div id="loadingSymbol">
        <div id="loadingText" style="position: relative; font-weight: bold">
          Loading...
        </div>
        <div
          class="dot-revolution"
          style="margin-left: 50%; margin-top: 40px"
        ></div>
      </div>

      <div id="settings" class="box">
        <h1 class="settingsHeader" onclick="collapseBox(this)">
          Settings/Tools <span class="triangle"></span>
        </h1>
        <div class="collapsable" style="height: 0px">
          <div id="nodeInfoContainer" class="box">
            <h2 class="settingsHeader" onclick="collapseBox(this)">
              Node Information <span class="triangle"></span>
            </h2>
            <div class="collapsable" id="nodeInfo" style="height: 0px">
              <h3><i>Hover over a node to see info about it here!</i></h3>
            </div>
          </div>
          <div id="interestingnessOptions" class="box">
            <h2 class="settingsHeader" onclick="collapseBox(this)">
              Show/Hide Nodes <span class="triangle"></span>
            </h2>
            <div class="collapsable" style="height: 0px">
              <hr />
              <button onclick="getInterest()">
                Compute interestingness for FOF/CNF derivations
              </button>

              <button
                class="interestHidden"
                id="interestScaleToggle"
                onclick="toggleInterestScaling()"
              >
                Enable interestingness scaling
              </button>
              <hr />

              <h3 class="interestHidden">Blacken boring nodes:</h3>
              <input
                type="range"
                class="mySlider interestHidden"
                name="interestingnessSlider"
                id="interestingnessSlider"
                oninput="recolorNodesByInterest()"
                min="-1.1"
                max="1.1"
                step="0.01"
                value="-1.1"
              />
              <hr class="interestHidden" />
              <button
                onclick="toggleConjectureVisible(this)"
                id="hideConjNodesButton"
              >
                Blacken non-lemmas
              </button>
              <button onclick="redrawNodesByInterest()">
                Remove black nodes
              </button>
              <button onclick="resetGraph()">Reset</button>
            </div>
          </div>

          <div id="about" class="box">
            <h2 class="settingsHeader" onclick="collapseBox(this)">
              About<span class="triangle"></span>
            </h2>
            <div class="collapsable" style="height: 0px; font-size: 12pt">
              <hr />
              <ul>
                <li>
                  The Interactive Derivation Viewer (IDV) <br />was written as part of the
                  <a href="https://tptp.org">TPTP World.</a>
                </li>
                <li> Daniel Li & Esteban Morales developed a standalone IDV.</li>
                <li>Jack McKeown finished the conversion and deployment.</li>
                <li>Jack McKeown adapted it for viewing intepretations.</li>
                <li>Joe Masterjohn started the conversion to a web app.</li>
                <li>Steven Trac wrote the original IDV as a Java applet.</li>
              </ul>
            </div>
          </div>

          <div id="back" class="box">
            <a href=""><h2>Back To Home</h2></a>
          </div>
        </div>
      </div>

      <div
        id="graph"
        style="
          text-align: center;
          width: 100%;
          height: 100%;
          border-left: 1px solid black;
        "
      ></div>

      <p id="proofText" style="display: none"></p>

      <script src="./BuildBundleWithNode/static/js/bundle.js"></script>
      <script>
  function wireWorldNodeClicks(inWorldMap) {
  // Graphviz outputs: <g class="node" id="w1"> ... <title>w1</title> ... </g>
  const nodes = document.querySelectorAll("svg g.node");
  nodes.forEach((g) => {
    const key = g.querySelector("title")?.textContent?.trim();
    if (!key) return;
    g.style.cursor = "pointer";

    // IMPORTANT: keep everything synchronous in this click handler
    // so the browser considers it a user gesture (no popup blocking).
    g.addEventListener("click", () => {
      const rawWorld = inWorldMap[key] || "";
      const converted = world_to_IIV_format(rawWorld);
      openIIVInNewTab_viaForm(converted);
    });
  });
}

        window.interestScalingBool = false;

        function removeTooltips() {
          // Remove all title tags beneath svg tags to remove tooltips
          let keys = Array.from(document.querySelectorAll("g.node title")).map(
            (x) => x.innerHTML
          );
          let titles = Array.from(document.querySelectorAll("svg title"));

          // We might have to try again if the graph isn't loaded yet
          if (keys.length < Object.keys(window.proof).length) {
            setTimeout(removeTooltips, 500);
            return;
          }

          console.log(
            `Removing ${titles.length} titles (${keys.length} nodes + edges)`
          );

          titles.forEach(function (x) {
            x.remove();
          });

          // Since titles have been removed and SVG texts
          // no longer link back to the global proof object,
          // we need to somehow have that data available on hover.
          let nodes = Array.from(document.querySelectorAll("g.node text"));
          nodes.forEach(function (x, i) {
            x.setAttribute("proofKey", keys[i]);
          });
        }

        if (window.interpretation){
          document.querySelector("#interestingnessOptions").hidden = true;
        }

        function show_original_graph() {
          setTimeout(function () {
            window.proofText = document.getElementById("proofText").innerText;
            window.originalProof = parseProof(proofText);
            window.proof = JSON.parse(JSON.stringify(originalProof));

            assignInterestingnessToHeightAndWidth();
            // showGV(proofToGV(proof));
            showGV(proofText);

            wireWorldNodeClicks(inWorldMap);
            if (window.interpretation) {
            	removeTooltips();
            }
            // Weird Hacks for initializing gui
            document.querySelector("#settings").children[0].click();
            setTimeout(
              () =>
                document
                  .querySelector("#nodeInfoContainer > .settingsHeader")
                  .click(),
              500
            );
          }, 200);
        }

        document
          .querySelector("#visualizeBtn")
          .addEventListener("click", show_original_graph);
        // if (window.addEventListener)
        // window.addEventListener("load", show_original_graph, false);
        // else if (window.attachEvent)
        // window.attachEvent("onload", show_original_graph);
      </script>
    </div>
    <script type="text/javascript">
/* ========= TPTP → IIV utilities ========= */

      function visualize() {
        document.querySelector("#index").style.display = "none";
        document.querySelector("#idv").style.display = "flex";
        document.querySelector("#proofText").innerHTML = document.getElementById("output").innerHTML;
      }

      if (document.getElementById("output").textContent.trim().includes("PROOF_GOES_HERE")) {
        document.getElementById("fileUploadBtn").style.display = "block";
        document.getElementById("visualizeBtn").style.display = "block";
        document.getElementById("fileUploadBtn").addEventListener("change", function () {
          let fr = new FileReader();
          fr.onload = function () {

            var output = fr.result

            worlds = output.split("\n").filter(line => (line.includes("$world") && line.includes("tff"))).map(world => world.split(":")[0].split(",").at(-1))
            // worlds -> [w1, w2]

            let worldDict = Object.fromEntries(worlds.map(w => [w, []]));
            // worldDict -> {w1: [], w2: []}

            local_world = worlds.find(w => output.includes(`$local_world = ${w}`))
            // local_world -> w1

            const regex = /\$accessible_world\((\w+),(\w+)\)/g;
            let match;

            while ((match = regex.exec(fr.result)) !== null) {
              const from = match[1];
              const to = match[2];
              if (worldDict[from]) {
                worldDict[from].push(to);
              } else {
                worldDict[from] = [to];
              }
            }
            // worldDict -> {w1: [w2], w2: [w1, w2]}

            function parseInWorldBlocks(text) {
              const dict = {};
              const target = "$in_world(";
              let idx = text.indexOf(target);

              while (idx !== -1) {
                // Move past "$in_world("
                let startKey = idx + target.length;

                // Read the key (up to the first comma)
                let commaIdx = text.indexOf(",", startKey);
                const key = text.slice(startKey, commaIdx).trim();

                // Now scan for matching parenthesis
                let depth = 1;
                let i = commaIdx + 1;
                while (i < text.length && depth > 0) {
                  if (text[i] === "(") depth++;
                  else if (text[i] === ")") depth--;
                  i++;
                }

                // Extract inside content
                const value = text.slice(commaIdx + 1, i - 1).trim();

                // Append to dictionary (separated by newlines if duplicate key)
                if (dict[key]) {
                  dict[key] += "\n" + value;
                } else {
                  dict[key] = value;
                }

                // Find next $in_world(
                idx = text.indexOf(target, i);
              }

              return dict;
            }

            // Example usage
            const result = parseInWorldBlocks(fr.result);
            console.log(result);

            function worldDictToGraphviz(worldDict) {




function inferName(lines) {
  for (const line of lines) {
    const m = line.match(BASE_TYPE_RE);
    if (m) return m[2]; // e.g., "fruit"
  }
  return "model";
}

function normalizeClause(text) {
  let t = text.trim();
  t = t.replace(/\.\s*$/u, ""); // drop trailing period
  if (t.startsWith("(") && t.endsWith(")")) return t;
  return `( ${t} )`;
}

/**
 * Reformat TPTP text into a single tff(NAME,interpretation, ...) block.
 * - Keeps all ",type," declarations as-is.
 * - Wraps remaining clauses into one conjunction.
 * - If an interpretation block already exists, returns input unchanged.
 *
 * @param {string} rawText
 * @returns {string}
 */
function world_to_IIV_format(rawText) {
  const lines = rawText.split(/\r?\n/);
  const typeLines = lines.filter((ln) => TYPE_LINE_RE.test(ln));
  const freeLines = lines.filter((ln) => !TYPE_LINE_RE.test(ln));
  const freeText = freeLines.join("\n").trim();

  // Already in interpretation form? pass through unchanged
  if (/\btff\s*\(\s*[^,]+,\s*interpretation\s*,/i.test(freeText)) {
    return rawText;
  }

  // Split into logical blocks
  let blocks = [];
  const chunks = freeText.split(/\r?\n\s*\r?\n/).filter((c) => c.trim());
  if (chunks.length > 1) {
    for (const ch of chunks) {
      blocks.push(...ch.split(SPLIT_RE).filter((b) => b.trim()));
    }
  } else if (freeText) {
    blocks = freeText.split(SPLIT_RE).filter((b) => b.trim());
  }

  if (blocks.length === 0 && freeText) blocks = [freeText];

  const clauses = blocks.length ? blocks.map(normalizeClause) : [];
  const name = inferName(typeLines);

  const joined = clauses.length ? clauses.join("\n  & ") : "";
  const interp = joined ? `tff(${name},interpretation,\n  ( ${joined} ) ).` : "";

  const body = typeLines.join("\n").replace(/\s+$/u, "");
  return interp ? `${body}\n\n${interp}\n` : `${body}\n`;
}



              let lines = [];
              lines.push("digraph G {");
              lines.push("    rankdir=TB;   // Top to bottom layout");
              lines.push("");

              // Nodes
              lines.push("    // Nodes");
              for (const node of Object.keys(worldDict)) {

                // TODO: change to system on tptp iiv tarskian
                
                worldStr = parseInWorldBlocks(fr.result) // returns a dict of in world tarskian interpretation
                var href = world_to_IIV_format(worldStr[node]) // 

                lines.push(`    ${node} [shape=circle,href="javascript:sendToIIV('${href}')"];`);
              }
              lines.push("");

              // Edges
              lines.push("    // Edges");
              for (const [from, tos] of Object.entries(worldDict)) {
                for (const to of tos) {
                  if (from === to) {
                    lines.push(`    ${from} -> ${to};  // self-loop`);
                  } else {
                    lines.push(`    ${from} -> ${to};`);
                  }
                }
              }

              lines.push("}");
              return lines.join("\n");
            }

            console.log(worldDictToGraphviz(worldDict));

            document.getElementById("output").textContent = worldDictToGraphviz(worldDict);
          };
          fr.readAsBinaryString(this.files[0]);
        });
      } else {

        visualize();
        show_original_graph();
      }

// Regexes (JS equivalents of your Python ones)
const TYPE_LINE_RE = /^\s*tff\([^)]*,\s*type\s*,/i;
const BASE_TYPE_RE = /^\s*tff\(\s*([A-Za-z0-9_]+)_type\s*,\s*type\s*,\s*([A-Za-z0-9_]+)\s*:\s*\$tType\s*\)\.\s*$/i;
const SPLIT_RE     = /\)\s*\.\s*(?=\()/g; // split between ").(" clause blocks

function inferName(lines){
  for (const line of lines){
    const m = line.match(BASE_TYPE_RE);
    if (m) return m[2]; // e.g., "fruit"
  }
  return "model";
}
function normalizeClause(text){
  let t = text.trim();
  t = t.replace(/\.\s*$/u, ""); // drop trailing period
  if (t.startsWith("(") && t.endsWith(")")) return t;
  return `( ${t} )`;
}
/**
 * Reformat TPTP text into a single tff(NAME,interpretation, ...) block.
 * - Keeps all ",type," declarations as-is.
 * - Wraps remaining clauses into one conjunction.
 * - If an interpretation block already exists, returns input unchanged.
 * @param {string} rawText
 * @returns {string}
 */
function world_to_IIV_format(rawText){
  const lines     = rawText.split(/\r?\n/);
  const typeLines = lines.filter((ln) => TYPE_LINE_RE.test(ln));
  const freeLines = lines.filter((ln) => !TYPE_LINE_RE.test(ln));
  const freeText  = freeLines.join("\n").trim();

  // Already in interpretation form? pass through unchanged
  if (/\btff\s*\(\s*[^,]+,\s*interpretation\s*,/i.test(freeText)){
    return rawText;
  }

  // Split into logical blocks
  let blocks = [];
  const chunks = freeText.split(/\r?\n\s*\r?\n/).filter((c) => c.trim());
  if (chunks.length > 1){
    for (const ch of chunks){
      blocks.push(...ch.split(SPLIT_RE).filter((b) => b.trim()));
    }
  } else if (freeText){
    blocks = freeText.split(SPLIT_RE).filter((b) => b.trim());
  }
  if (blocks.length === 0 && freeText) blocks = [freeText];

  const clauses = blocks.length ? blocks.map(normalizeClause) : [];
  const name    = inferName(typeLines);

  const joined = clauses.length ? clauses.join("\n  & ") : "";
  const interp = joined ? `tff(${name},interpretation,\n  ( ${joined} ) ).` : "";

  const body = typeLines.join("\n").replace(/\s+$/u, "");
  return interp ? `${body}\n\n${interp}\n` : `${body}\n`;
}

/* ========= Posting to TPTP IIV without CORS (opens new tab) ========= */
/* Use a real form POST to avoid CORS; fetch() would be blocked by CORS. */
function openIIVInNewTab_viaForm(convertedText){
  const form = document.createElement("form");
  form.method = "POST";
  form.action = "https://tptp.org/cgi-bin/SystemOnTPTPFormReply";
  form.target = "_blank";

  const add = (name, value) => {
    const input = document.createElement("input");
    input.type = "hidden";
    input.name = name;
    input.value = value;
    form.appendChild(input);
  };

  // Minimal fields for IIV visualizer
  add("ProblemSource", "FORMULAE");
  add("FORMULAEProblem", convertedText);
  add("SolutionFormat", "TPTP");
  add("QuietFlag", "-q01");
  add("SubmitButton", "ProcessSolution");

  add("System___IIV---0.0", "IIV---0.0");
  add("TimeLimit___IIV---0.0", "60");
  add("Transform___IIV---0.0", "none");
  add("Format___IIV---0.0", "tptp:raw");
  add("Command___IIV---0.0", "run_IIV %s");

  document.body.appendChild(form);
  form.submit();
  form.remove();
}

/* ========= Helpers to parse your “worlds” file ========= */

/** Parse $in_world(World, <...tptp...>) blocks into { World: "tptp...\n..." }  */
function parseInWorldBlocks(text){
  const dict = {};
  const target = "$in_world(";
  let idx = text.indexOf(target);

  while (idx !== -1){
    const startKey = idx + target.length;
    const commaIdx = text.indexOf(",", startKey);
    if (commaIdx === -1) break;

    const key = text.slice(startKey, commaIdx).trim();

    // Scan for matching parenthesis
    let depth = 1;
    let i = commaIdx + 1;
    while (i < text.length && depth > 0){
      const ch = text[i];
      if (ch === "(") depth++;
      else if (ch === ")") depth--;
      i++;
    }
    const value = text.slice(commaIdx + 1, i - 1).trim();

    dict[key] = dict[key] ? (dict[key] + "\n" + value) : value;
    idx = text.indexOf(target, i);
  }
  return dict;
}

/** Build world adjacency from $accessible_world(X,Y) facts */
function parseAccessibleWorlds(text){
  const worldDict = {};
  const re = /\$accessible_world\((\w+),\s*(\w+)\)/g;
  let m;
  while ((m = re.exec(text)) !== null){
    const from = m[1], to = m[2];
    if (!worldDict[from]) worldDict[from] = [];
    worldDict[from].push(to);
  }
  return worldDict;
}

/** Extract declared worlds like:  tff(..., ... $world = wN ...)  (adjust to your exact format) */
function parseDeclaredWorlds(text){
  return text.split("\n")
    .filter(line => (line.includes("$world") && line.includes("tff")))
    .map(world => {
      const left = world.split(":")[0];              // tff(name,type,...
      const parts = left.split(",");
      return parts[parts.length - 1].trim();         // take last token as world name
    });
}

/* ========= Graphviz DOT builder ========= */
/* Encodes converted TPTP into a safe JS argument inside the href attribute. */
function worldDictToGraphviz(worldDict, worldTextMap){
  const lines = [];
  lines.push("digraph G {");
  lines.push("  rankdir=TB;");
  lines.push("");
  lines.push("  // Nodes");

  for (const node of Object.keys(worldDict)){
    const rawWorld   = worldTextMap[node] || "";
    const converted  = world_to_IIV_format(rawWorld);
    const encoded    = encodeURIComponent(converted);
    // Use javascript: with encoded payload; decoded at call site to avoid breaking attributes
  //  const href = `javascript:openIIVInNewTab_viaForm(decodeURIComponent('${encoded}'))`;
//    lines.push(`  ${node} [shape=circle, id="${node}", label="${node}", tooltip="${node}", href="${href}"];`);
    lines.push(`  ${node} [shape=circle, id="${node}", label="${node}", tooltip="${node}"];`);
  }

  lines.push("");
  lines.push("  // Edges");
  for (const [from, tos] of Object.entries(worldDict)){
    for (const to of tos){
      lines.push(`  ${from} -> ${to};`);
    }
  }

  lines.push("}");
  return lines.join("\n");
}

/* ========= Wire up file input ========= */

(function init(){
  const fileInput = document.getElementById("fileUploadBtn");
  const outPre    = document.getElementById("output");

  if (!fileInput || !outPre){
    // Elements not found; nothing to wire.
    return;
  }

  // Optional UI toggles if these IDs exist
  const visualizeBtn = document.getElementById("visualizeBtn");
  if (visualizeBtn) visualizeBtn.style.display = "block";
  fileInput.style.display = "block";

  fileInput.addEventListener("change", function(){
    const file = this.files && this.files[0];
    if (!file) return;

    const fr = new FileReader();
    fr.onload = () => {
      const inputText = String(fr.result);

      // Parse once
      const inWorldMap   = parseInWorldBlocks(inputText);      // { w1: "...tptp...", ... }
      const worldAdj     = parseAccessibleWorlds(inputText);   // { w1: [w2,...], ... }

      // If no edges declared, still create nodes from declared worlds (optional)
      if (Object.keys(worldAdj).length === 0){
        const declared = parseDeclaredWorlds(inputText);
        for (const w of declared){ if (!worldAdj[w]) worldAdj[w] = []; }
      }

      // Build DOT
      const dot = worldDictToGraphviz(worldAdj, inWorldMap);
      outPre.textContent = dot;  // You can feed this into viz.js to render the graph
    };
    fr.readAsText(file, "utf-8"); // Use text (not readAsBinaryString)
  });
})();

    </script>
  </body>
</html>
