<html>
  <body>
    <script
      src="https://unpkg.com/@hpcc-js/wasm@1.20.1/dist/index.js"
      type="text/javascript"
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-graphviz@4.4.0/build/d3-graphviz.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script>
      document.body.onload = function() {
        window.stuff = document.querySelectorAll("body > pre");
        window.stuff[0].innerText = "";
        window.stuff[1].innerText = "";
      };
    </script>
    <script>
      window.interpretation = true;
    </script>

    <style>
      html,
      body {
        font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
        padding: 0px;
        width: 100%;
        height: 100%;
      }

      * {
        /* word-break: break-all; */
      }

      body {
        justify-content: space-around;
        align-items: flex-start;
      }

      /* loading symbol stuff */

      #loadingSymbol,
      g.node,
      g.node > polygon,
      g.node > ellipse {
        transition: opacity 0.3s, fill 0.3s;
      }

      #loadingSymbol {
        position: fixed;
        padding: 45px;
        right: 20px;
        top: 20px;
        background-color: rgba(150, 150, 150, 0.2);
        border-radius: 100px;
        box-shadow: 2px 2px 5px 0px rgb(177, 177, 177);
        opacity: 1;
      }

      #loadingSymbol.hidden {
        opacity: 0;
        height: 0px;
        width: 0px;
        padding: 0px;
        margin: 0px;
      }

      /* settings stuff */

      .interestHidden {
        display: none;
      }

      .settingsHeader {
        cursor: pointer;
      }

      .triangle {
        border: solid black;
        border-width: 0 3px 3px 0;
        display: inline-block;
        padding: 3px;

        transform: rotate(45deg) translateY(-4px);
      }

      .open > .triangle {
        transform: rotate(-135deg) translate(-3px, 3px);
      }

      .collapsable {
        overflow: auto;
        padding: 0px;
      }

      .box {
        border: 1px solid black;
        background: rgba(100, 100, 100, 0.4);
        padding: 10px;
        margin: 5px;
      }

      #nodeInfo {
        overflow: auto;
        font-family: monospace;
      }

      #settings {
        /* position: fixed; */
        left: 5px;
        max-height: 96%;
        width: 550px;
        top: 2%;
        user-select: none;
        overflow: auto;
        border-right: 1px solid black;

        font-size: 0.87em;
      }

      #tptpTextarea {
        display: none;
        width: 90%;
        margin: auto;
        border: 0px;
        min-height: 100px;
        height: 0px;
      }

      #tptpTextarea.open {
        height: auto;
        display: block;
      }

      button,
      input[type="button"] {
        position: relative;
        display: block;
        margin-top: 10px;

        padding: 10px;
        border-radius: 5px;
        border: 1px solid black;
        background-color: rgb(201, 201, 201);
        cursor: pointer;

        font-size: 0.9em;
      }

      button:hover,
      input[type="button"]:hover {
        top: -1px;
        left: -1px;
        box-shadow: 1px 1px 7px -3px black;
      }

      .settingsHeader {
        line-height: 2.5;
        margin: 0px;
        padding: 0px;
      }

      /* graphviz */

      #graph svg {
        width: 100%;
        height: 100%;
      }

      /* generated slider css */

      input[type="range"].mySlider {
        -webkit-appearance: none;
        width: 90%;
        margin: auto;
      }
      input[type="range"].mySlider:focus {
        outline: none;
      }
      input[type="range"].mySlider::-webkit-slider-runnable-track {
        width: 100%;
        height: 17.8px;
        cursor: pointer;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
        background: rgba(192, 192, 190, 0.76);
        border-radius: 0px;
        border: 1.2px solid rgba(0, 0, 0, 0);
      }
      input[type="range"].mySlider::-webkit-slider-thumb {
        box-shadow: 1.7px 1.7px 9.5px rgba(0, 0, 0, 0.51),
          0px 0px 1.7px rgba(13, 13, 13, 0.51);
        border: 2.4px solid rgba(44, 30, 0, 0.56);
        height: 29px;
        width: 26px;
        border-radius: 9px;
        background: rgba(148, 136, 126, 0.98);
        cursor: pointer;
        -webkit-appearance: none;
        margin-top: -6.8px;
      }
      input[type="range"].mySlider:focus::-webkit-slider-runnable-track {
        background: rgba(192, 192, 190, 0.76);
      }
      input[type="range"].mySlider::-moz-range-track {
        width: 100%;
        height: 17.8px;
        cursor: pointer;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
        background: rgba(192, 192, 190, 0.76);
        border-radius: 0px;
        border: 1.2px solid rgba(0, 0, 0, 0);
      }
      input[type="range"].mySlider::-moz-range-thumb {
        box-shadow: 1.7px 1.7px 9.5px rgba(0, 0, 0, 0.51),
          0px 0px 1.7px rgba(13, 13, 13, 0.51);
        border: 2.4px solid rgba(44, 30, 0, 0.56);
        height: 29px;
        width: 26px;
        border-radius: 9px;
        background: rgba(148, 136, 126, 0.98);
        cursor: pointer;
      }
      input[type="range"].mySlider::-ms-track {
        width: 100%;
        height: 17.8px; 
        cursor: pointer;
        background: transparent;
        border-color: transparent;
        color: transparent;
      }
      input[type="range"].mySlider::-ms-fill-lower {
        background: rgba(192, 192, 190, 0.76);
        border: 1.2px solid rgba(0, 0, 0, 0);
        border-radius: 0px;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
      }
      input[type="range"].mySlider::-ms-fill-upper {
        background: rgba(192, 192, 190, 0.76);
        border: 1.2px solid rgba(0, 0, 0, 0);
        border-radius: 0px;
        box-shadow: 0.3px 0.3px 6px rgba(0, 0, 99, 0.58),
          0px 0px 0.3px rgba(0, 0, 125, 0.58);
      }
      input[type="range"].mySlider::-ms-thumb {
        box-shadow: 1.7px 1.7px 9.5px rgba(0, 0, 0, 0.51),
          0px 0px 1.7px rgba(13, 13, 13, 0.51);
        border: 2.4px solid rgba(44, 30, 0, 0.56);
        height: 29px;
        width: 26px;
        border-radius: 9px;
        background: rgba(148, 136, 126, 0.98);
        cursor: pointer;
        height: 17.8px;
      }
      input[type="range"].mySlider:focus::-ms-fill-lower {
        background: rgba(192, 192, 190, 0.76);
      }
      input[type="range"].mySlider:focus::-ms-fill-upper {
        background: rgba(192, 192, 190, 0.76);
      }

      /**
 * ==============================================
 * Dot Revolution
 * ==============================================
 */
      .dot-revolution {
        position: relative;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
      }

      .dot-revolution::before,
      .dot-revolution::after {
        content: "";
        display: inline-block;
        position: absolute;
      }

      .dot-revolution::before {
        left: 0;
        top: -15px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        transform-origin: 5px 20px;
        animation: dotRevolution 1.4s linear infinite;
      }

      .dot-revolution::after {
        left: 0;
        top: -30px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        transform-origin: 5px 35px;
        animation: dotRevolution 1s linear infinite;
      }

      @keyframes dotRevolution {
        0% {
          transform: rotateZ(0deg) translate3d(0, 0, 0);
        }
        100% {
          transform: rotateZ(360deg) translate3d(0, 0, 0);
        }
      }

      /*# sourceMappingURL=three-dots.css.map */
    </style>
    <div id="index">
      <pre id="output" style="display: none">
PROOF_GOES_HERE
      </pre>

      <input type="file" name="fileUploadBtn" id="fileUploadBtn" style="display:none"/>
      <button id="visualizeBtn" onclick="visualize()" style="display:none">Visualize</button>
    </div>

    <div id="idv" style="display: none; align-items: flex-start; height: 100%">
      <div id="loadingSymbol">
        <div id="loadingText" style="position: relative; font-weight: bold">
          Loading...
        </div>
        <div
          class="dot-revolution"
          style="margin-left: 50%; margin-top: 40px"
        ></div>
      </div>

      <div id="settings" class="box">
        <h1 class="settingsHeader" onclick="collapseBox(this)">
          Settings/Tools <span class="triangle"></span>
        </h1>
        <div class="collapsable" style="height: 0px">
          <div id="nodeInfoContainer" class="box">
            <h2 class="settingsHeader" onclick="collapseBox(this)">
              Node Information <span class="triangle"></span>
            </h2>
            <div class="collapsable" id="nodeInfo" style="height: 0px">
              <h3><i>Hover over a node to see info about it here!</i></h3>
            </div>
          </div>
          <div id="interestingnessOptions" class="box">
            <h2 class="settingsHeader" onclick="collapseBox(this)">
              Show/Hide Nodes <span class="triangle"></span>
            </h2>
            <div class="collapsable" style="height: 0px">
              <hr />
              <button onclick="getInterest()">
                Compute interestingness for FOF/CNF derivations
              </button>

              <button
                class="interestHidden"
                id="interestScaleToggle"
                onclick="toggleInterestScaling()"
              >
                Enable interestingness scaling
              </button>
              <hr />

              <h3 class="interestHidden">Blacken boring nodes:</h3>
              <input
                type="range"
                class="mySlider interestHidden"
                name="interestingnessSlider"
                id="interestingnessSlider"
                oninput="recolorNodesByInterest()"
                min="-1.1"
                max="1.1"
                step="0.01"
                value="-1.1"
              />
              <hr class="interestHidden" />
              <button
                onclick="toggleConjectureVisible(this)"
                id="hideConjNodesButton"
              >
                Blacken non-lemmas
              </button>
              <button onclick="redrawNodesByInterest()">
                Remove black nodes
              </button>
              <button onclick="resetGraph()">Reset</button>
            </div>
          </div>

          <div id="about" class="box">
            <h2 class="settingsHeader" onclick="collapseBox(this)">
              About<span class="triangle"></span>
            </h2>
            <div class="collapsable" style="height: 0px; font-size: 12pt">
              <hr />
              <ul>
                <li>
                  The Interactive Interpretation Viewer (IIV) was written as part of the
                  <a href="https://tptp.org">TPTP World.</a>
                </li>
                <li> <a href="https://www.debugdaniel.com">Daniel Li </a>& <a href="https://esteban-morales.onrender.com">Esteban Morales</a> developed an interpretation viewer for Tarskian and Kripean interpretations.</li>
              </ul>
            </div>
          </div>

        </div>
      </div>

      <div
        id="graph"
        style="
          text-align: center;
          width: 100%;
          height: 100%;
          border-left: 1px solid black;
        "
      ></div>

      <p id="proofText" style="display: none"></p>

      <script src="./BuildBundleWithNode/static/js/bundle.js"></script>


<script type="text/javascript">


function removeTooltips() {
  const keys   = Array.from(document.querySelectorAll("g.node title")).map(x => x.innerHTML);
  const titles = Array.from(document.querySelectorAll("svg title"));
  if (!window.proof || keys.length < Object.keys(window.proof).length) {
    setTimeout(removeTooltips, 500);
    return;
  }
  titles.forEach(x => x.remove());
  const nodes = Array.from(document.querySelectorAll("g.node text"));
  nodes.forEach((x, i) => x.setAttribute("proofKey", keys[i]));
}

if (window.interpretation) {
  const el = document.querySelector("#interestingnessOptions");
  if (el) el.hidden = true;
}

function show_original_graph() {
  setTimeout(function () {
    window.proofText     = document.getElementById("proofText").innerText;
    window.originalProof = parseProof(proofText);
    window.proof         = JSON.parse(JSON.stringify(originalProof));
    

    console.log(document.getElementById("proofText").innerText)

    assignInterestingnessToHeightAndWidth();
    showGV(proofText);

    if (window.interpretation) removeTooltips();

    const settings = document.querySelector("#settings");
    if (settings && settings.children[0]) settings.children[0].click();
    setTimeout(() => {
      const hdr = document.querySelector("#nodeInfoContainer > .settingsHeader");
      if (hdr) hdr.click();
    }, 500);
  }, 200);
}

document.querySelector("#visualizeBtn")?.addEventListener("click", show_original_graph);

function visualize() {
  const indexEl = document.querySelector("#index");
  const idvEl   = document.querySelector("#idv");
  const proofEl = document.querySelector("#proofText");
  const outEl   = document.getElementById("output");
  if (indexEl) indexEl.style.display = "none";
  if (idvEl)   idvEl.style.display = "flex";
  if (proofEl && outEl) proofEl.textContent = outEl.textContent;
}

// FIXED: Now handles multiline type declarations
const TYPE_LINE_RE = /^\s*t[hf]f\s*\([^)]*,\s*type\s*,/mi;

// FIXED: Now handles multiline base type declarations with [\s\S]* for any character including newlines
const BASE_TYPE_RE = /^\s*t[hf]f\s*\(\s*([A-Za-z0-9_]+)_type\s*,\s*type\s*,\s*([A-Za-z0-9_]+)\s*:\s*\$tType\s*\)\s*\.\s*$/mis;

const SPLIT_RE = /\)\s*\.\s*(?=\()/g;

// Helper function to check if a line matches a type declaration (handles multiline)
function isTypeLine(line) {
  // Normalize multiline input by replacing newlines with spaces for checking
  const normalizedLine = line.replace(/\r?\n/g, ' ');
  return TYPE_LINE_RE.test(normalizedLine);
}

function inferName(lines) {
  for (const line of lines) {
    // Handle multiline by normalizing before matching
    const normalizedLine = line.replace(/\r?\n/g, ' ');
    const m = normalizedLine.match(BASE_TYPE_RE);
    if (m) return m[2];
  }
  return "model";
}

function normalizeClause(text) {
  let t = text.trim();
  t = t.replace(/\.\s*$/u, "");
  if (t.startsWith("(") && t.endsWith(")")) return t;
  return `( ${t} )`;
}

function world_to_IIV_format(rawText) {
  const lines = rawText.split(/\r?\n/);
  
  // FIXED: Handle multiline type declarations
  const typeLines = [];
  const freeLines = [];
  
  let currentBlock = "";
  let inTypeDecl = false;
  
  for (const line of lines) {
    // Check if this line starts a type declaration
    if (/^\s*t[hf]f\s*\(/i.test(line) && /type/i.test(line)) {
      inTypeDecl = true;
      currentBlock = line;
    } else if (inTypeDecl) {
      currentBlock += "\n" + line;
      // Check if we've completed the declaration (ends with ).)
      if (/\)\s*\.\s*$/.test(line)) {
        if (isTypeLine(currentBlock)) {
          typeLines.push(currentBlock);
        } else {
          freeLines.push(currentBlock);
        }
        currentBlock = "";
        inTypeDecl = false;
      }
    } else {
      freeLines.push(line);
    }
  }
  
  // Handle any incomplete block
  if (currentBlock) {
    if (isTypeLine(currentBlock)) {
      typeLines.push(currentBlock);
    } else {
      freeLines.push(currentBlock);
    }
  }
  
  const freeText = freeLines.join("\n").trim();

  // FIXED: Check for interpretation with multiline support
  if (/\bt[hf]f\s*\(\s*[^,]+,\s*interpretation\s*,/mis.test(freeText)) {
    return rawText;
  }

  let blocks = [];
  const chunks = freeText.split(/\r?\n\s*\r?\n/).filter(c => c.trim());
  if (chunks.length > 1) {
    for (const ch of chunks) blocks.push(...ch.split(SPLIT_RE).filter(b => b.trim()));
  } else if (freeText) {
    blocks = freeText.split(SPLIT_RE).filter(b => b.trim());
  }
  if (!blocks.length && freeText) blocks = [freeText];

  if (blocks.length === 1) {
    const topLevel = splitTopLevelClauses(blocks[0]);
    if (topLevel.length > 1) blocks = topLevel;
  }

  const clauses = blocks.length ? blocks.map(normalizeClause) : [];
  const name = inferName(typeLines);

  const joined = clauses.length ? clauses.join("\n  & ") : "";
  const interp = joined ? `tff(${name},interpretation,\n  ( ${joined} ) ).` : "";

  const body = typeLines.join("\n").replace(/\s+$/u, "");
  return interp ? `${body}\n\n${interp}\n` : `${body}\n`;
}

function splitTopLevelClauses(s) {
  const parts = [];
  let buf = "";
  let depth = 0;

  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    buf += ch;

    if (ch === "(") depth++;
    else if (ch === ")") depth = Math.max(0, depth - 1);

    if (depth === 0 && ch === ")") {
      let j = i + 1;
      while (j < s.length && /\s/.test(s[j])) j++;
      if (s[j] === "(") {
        parts.push(buf.trim());
        buf = "";
        i = j - 1;
      }
    }
  }

  if (buf.trim()) parts.push(buf.trim());
  return parts;
}

function parseDeclarations(rawInput) {
  const lines = rawInput.split(/\r?\n/);
  const out = [];
  let started = false;
  let currentDecl = "";
  let inDecl = false;

  for (let i = 0; i < lines.length; i++) {
    const ln = lines[i];
    
    // Check if this line starts a declaration
    if (/^\s*t[hf]f\s*\(/i.test(ln)) {
      // Might be starting a declaration
      currentDecl = ln;
      inDecl = true;
      
      // Check if it's complete on this line
      if (/\)\s*\.\s*$/.test(ln)) {
        if (isTypeLine(currentDecl)) {
          started = true;
          out.push(currentDecl);
        }
        currentDecl = "";
        inDecl = false;
      }
    } else if (inDecl) {
      // Continue building the current declaration
      currentDecl += "\n" + ln;
      
      // Check if we've completed it
      if (/\)\s*\.\s*$/.test(ln)) {
        if (isTypeLine(currentDecl)) {
          started = true;
          out.push(currentDecl);
        }
        currentDecl = "";
        inDecl = false;
      }
    } else if (!started) {
      // Haven't hit any declarations yet
      if (ln.trim() === "") {
        out.push(ln);
      }
    } else if (started && ln.trim() === "") {
      // Blank lines between declarations
      out.push(ln);
    } else if (started && ln.trim() !== "") {
      // Non-declaration after declarations started - stop
      break;
    }
  }

  return out.join("\n");
}

function parseInWorldBlocks(text) {
  const worldSet = new Set();
  
  // FIXED: Handle multiline world declarations
  const worldDeclRe = /t[hf]f\s*\([^,]+,\s*type\s*,\s*([A-Za-z_]\w*)\s*:\s*\$world\s*\)\s*\./gims;
  let m;
  while ((m = worldDeclRe.exec(text)) !== null) {
    worldSet.add(m[1]);
  }
  const worlds = Array.from(worldSet);

  const dict = {};
  for (const w of worlds) dict[w] = "";

  const target = "$in_world(";
  let idx = text.indexOf(target);

  while (idx !== -1) {
    const startArg = idx + target.length;

    let i = startArg;
    while (i < text.length && /\s/.test(text[i])) i++;
    let argStart = i;

    while (i < text.length && /[A-Za-z0-9_]/.test(text[i])) i++;
    const firstArg = text.slice(argStart, i);

    while (i < text.length && /\s/.test(text[i])) i++;
    if (text[i] !== ",") {
      idx = text.indexOf(target, idx + 1);
      continue;
    }
    const commaIdx = i;

    let depth = 1;
    i = commaIdx + 1;
    while (i < text.length && depth > 0) {
      const ch = text[i];
      if (ch === "(") depth++;
      else if (ch === ")") depth--;
      i++;
    }
    const value = text.slice(commaIdx + 1, i - 1).trim();

    if (worldSet.has(firstArg)) {
      dict[firstArg] = (dict[firstArg] ? dict[firstArg] + "\n" : "") + value;
    } else {
      const lookback = text.slice(Math.max(0, idx - 400), idx);
      // FIXED: Handle multiline quantifier declarations
      const qRe = /!\s*\[\s*([A-Za-z_]\w*)\s*:\s*\$world\s*\]\s*:/s;
      const qm = qRe.exec(lookback);
      const boundVar = qm ? qm[1] : null;

      if (boundVar && boundVar === firstArg && worlds.length) {
        for (const w of worlds) {
          dict[w] = (dict[w] ? dict[w] + "\n" : "") + value;
        }
      } else {
        dict.__unresolved = (dict.__unresolved ? dict.__unresolved + "\n" : "") + value;
      }
    }

    idx = text.indexOf(target, i);
  }

  return dict;
}

function parseAccessibleWorlds(text) {
  const worldDict = {};
  // FIXED: Handle multiline accessible world declarations
  const re = /\$accessible_world\s*\(\s*(\w+)\s*,\s*(\w+)\s*\)/gs;
  let m;
  while ((m = re.exec(text)) !== null) {
    const from = m[1], to = m[2];
    if (!worldDict[from]) worldDict[from] = [];
    worldDict[from].push(to);
  }
  return worldDict;
}

function parseDeclaredWorlds(text) {
  const worlds = [];
  // FIXED: Handle multiline world declarations properly
  const lines = text.split(/\r?\n/);
  let currentBlock = "";
  
  for (const line of lines) {
    currentBlock += line + "\n";
    
    // Check if we have a complete declaration
    if (/\)\s*\.\s*$/.test(line)) {
      // Check if this block contains a world declaration
      if (/\$world/i.test(currentBlock) && /t[hf]f/i.test(currentBlock)) {
        // Extract the world name
        const match = currentBlock.match(/t[hf]f\s*\([^,]+,\s*type\s*,\s*([A-Za-z_]\w*)\s*:\s*\$world/is);
        if (match) {
          worlds.push(match[1].trim());
        }
      }
      currentBlock = "";
    }
  }
  
  return worlds;
}

function worldDictToGraphviz(worldAdj) {
  const lines = [];
  lines.push("digraph G {");
  lines.push("  rankdir=TB;");
  lines.push("");
  lines.push("  // Nodes");
  for (const node of Object.keys(worldAdj)) {
    lines.push(`  ${node} [shape=circle, id="${node}", label="${node}", tooltip="${node}"];`);
  }
  lines.push("");
  lines.push("  // Edges");
  for (const [from, tos] of Object.entries(worldAdj)) {
    for (const to of tos) lines.push(`  ${from} -> ${to};`);
  }
  lines.push("}");
  return lines.join("\n");
}

function openIIVInNewTab_viaForm(convertedText) {
  const form = document.createElement("form");
  form.method = "POST";
  form.action = "https://tptp.org/cgi-bin/SystemOnTPTPFormReply";
  form.target = "_blank";
  const add = (name, value) => {
    const input = document.createElement("input");
    input.type = "hidden";
    input.name = name;
    input.value = value;
    form.appendChild(input);
  };
  console.log(`this is the converted text being sent to TSTP\n${convertedText}`)
  add("ProblemSource", "FORMULAE");
  add("FORMULAEProblem", convertedText);
  add("SolutionFormat", "TPTP");
  add("QuietFlag", "-q01");
  add("SubmitButton", "ProcessSolution");

  add("System___IIV---0.0", "IIV---0.0");
  add("TimeLimit___IIV---0.0", "60");
  add("Transform___IIV---0.0", "none");
  add("Format___IIV---0.0", "tptp:raw");
  add("Command___IIV---0.0", "run_IIV %s");

  document.body.appendChild(form);
  form.submit();
  form.remove();
}

function getSvgContainer() {
  return document.querySelector("#graph, .graph, .graph-container, svg") || document.querySelector("svg");
}

function waitForSvgNodes(callback, tries = 40) {
  const svg = getSvgContainer();
  if (!svg) { if (tries) return setTimeout(() => waitForSvgNodes(callback, tries - 1), 100); return; }
  const hasNodes = svg.querySelectorAll("g.node").length > 0;
  if (!hasNodes) { if (tries) return setTimeout(() => waitForSvgNodes(callback, tries - 1), 100); return; }
  callback(svg);
}

function wireDelegatedClicks(inWorldMap) {
  const svg = getSvgContainer();
  if (!svg){console.log("failed to get svg,"); return;}

  if (svg.__worldClickBound) return;
  svg.__worldClickBound = true;

  svg.addEventListener("click", (e) => {
    const g = e.target.closest && e.target.closest("g.node");
    if (!g) return;

    const key = g.getAttribute("id")
             || g.querySelector("title")?.textContent?.trim()
             || g.querySelector("text")?.textContent?.trim();

    if (!key) return;

    const rawWorld = inWorldMap[key] || "";
    const converted = `${window.__worldDeclarations} ` + world_to_IIV_format(rawWorld)
    
    openIIVInNewTab_viaForm(converted);
  }, false);
}

(function init(){
  const fileInput = document.getElementById("fileUploadBtn");
  const outPre = document.getElementById("output");
  const visualizeBtn = document.getElementById("visualizeBtn");

  if (visualizeBtn) visualizeBtn.style.display = "block";
  fileInput.style.display = "block";

  fileInput.addEventListener("change", function(){
    const file = this.files && this.files[0];
    if (!file) return;
    
    const fr = new FileReader();
    fr.onload = () => {
      const inputText = String(fr.result);
      console.log(`${inputText}`);

      const inWorldMap = parseInWorldBlocks(inputText);
      window.__inWorldMap = inWorldMap;
      window.__worldDictsFromInput = parseInWorldBlocks(inputText);
      window.__worldDeclarations = parseDeclarations(inputText);

      console.log("world 2 is :")
      console.log(window.__worldDictsFromInput["w2"]);

      console.log("world 1 is ");
      console.log(window.__worldDictsFromInput["w1"]);

      console.log("declarations are ");
      console.log(window.__worldDeclarations);

      let worldAdj = parseAccessibleWorlds(inputText);
      if (Object.keys(worldAdj).length === 0) {
        const declared = parseDeclaredWorlds(inputText);
        worldAdj = Object.fromEntries(declared.map(w => [w, []]));
      }

      const dot = worldDictToGraphviz(worldAdj);
      outPre.textContent = dot;

      showGV(dot);

      waitForSvgNodes(() => wireDelegatedClicks(window.__inWorldMap));
    };
    fr.readAsText(file, "utf-8");
  });

  if (!document.getElementById("output").textContent.trim().includes("PROOF_GOES_HERE")) {
    visualize();
    show_original_graph();
  }
})();

</script>
  </body>
</html>
